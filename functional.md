码农站在抽象性原理的基础上，把那些库函数尽为自己所用。他们不知道自己的程序做了什么，却自以为已经改变了世界。

本文档为CS 3110的学习笔记。

# 什么是函数式编程？
1 + 2 = 3.

命令式编程的人是这么想的：找两个内存，一个写上1，一个写上2，再找一个空内存。找一个加法二极管，把1和2输入，把输出的结果放进第三个内存，把前两个内存删掉，把第三个内存存起来。等号代表着赋值。

函数式编程的人是这么想的：有1，2，3三个同属自然数集的元素，定义一个二元映射(+)，1和2的笛卡尔积在它的下面映射为3。等号代表着映射。
可以看到，函数式编程的特点是用抽象的映射思考，建立在抽象性原理的基础上，注重逻辑，不去考虑如何实现。

可是，什么是映射呢？
## 映射
符号语言首先的要素是基本符号，也就是1，2，3这些。映射从本质上是基本符号的笛卡尔积集，但大家一般把它理解为基本符号与基本符号的关系。1 + 2 = 3 描述的就是（1，2）与（3）之间拥有的关系。如果把运算理解为在基本符号间建立、化简关系，那么映射就变得顶顶重要了。

基本符号，乃至它们的组合的一个重要特点是不可分割。试问如果我们可以随便修改“1”或者“hello world”，那么它们就不再基本：我们可以找到比它们更基本的东西。然而，在命令式编程中，什么都可以修改，这就让映射的抽象变得困难。把函数理解成一堆代码更是让映射的抽象无法接受。同一个对象输入函数两次会得到不同的结果！可变性(mutability)思想把任何一个对象都想象成由几个参数组成的基本符号，把函数并不看成对一个对象的修修补补，而看成找到另一个对象，使其与这个对象有一定的关系，这就是不可变性(immutability)思想。

关系可以随便定义，这是数学和逻辑赋予使用者的自由。自定义映射关系是一个成熟语言应该赋予给使用者的能力。然而，在命令式编程中，映射关系被藏在大量的命令之中，模糊不清。当你print("hello world")的时候，你不知道在字符串"hello world"和其他什么东西之间建立了映射。当你想定义更复杂的映射，例如映射的映射时，命令式编程就罢工了：没有高阶编程（函数的函数，lambda函数）带来的抽象性。

## 函数式编程的基本单位：变量、表达式、函数及其赋值
为了解决命令式编程无法深入抽象思考的问题，函数式编程应运而生。

为了方便交互，我们一般定义几种基本符号。整数、字符、真假、虚无都是基本符号。基本符号与基本符号之间的对应就是计算的过程。
在函数式编程中，所有的关系都是函数——一种基本符号与另一种基本符号的关系。四则运算是，if是，顺序算符也是。更重要的是如何根据这些基本函数定义新函数，并通过一层层抽象简化思考。

定义函数，就是定义逻辑关系。巧妇难为无米之炊，逻辑关系需要抽象材料的支撑，这“米”就是变量。变量可以取它应该属于集合的任何元素，而我们可以用符号表达变量之间的关系。let f a b c = a + b + c 从纯抽象的角度，就是定义了(a, b, c)与a+b+c的值的映射。当然这也可以理解为a与fun b c -> a + b + c的映射，在后一个函数里a已经被赋值，它就有了一个基本值，在后面的函数里a就变成了一个基本符号。也就是说多元函数不仅可以看成笛卡尔积的函数，也可以看成一元函数的一元函数。函数中的变量称为函数的参数。

有了函数，我们应该给它起个名字，这样就不用啰嗦地再写一大堆参数和逻辑关系了。这就完成了函数的定义。想用它的时候，我们写下这个函数名，再指明其对应的几个参数是什么，（那几个参数可能是其他基本符号的组合，甚至是其他函数，那时我们就递归地为那些函数赋值），通过几个旧基本符号就得到了几个新基本符号。这就是函数的赋值。在之后的解释器一节中会更深入地讨论赋值问题，尤其是函数带来的变量代入问题。

特别要提到的情形是函数的定义中用到了自己名字的情形，这就是递归。递归栈是如何处理这种函数关系的解决办法，尽管函数式编程并不关心栈的细节。在函数式编程中这就是实现循环的方式。事实上，任何一个循环都可以转化成一个指明有几个变量要存起来的尾递归。尾递归优化可以避免递归层数过多导致的堆栈溢出(stack overflow)。
## 函数的类型集合与数据结构
基本符号不能脱离其定义的集合而存在，而我们不想把不同类型的符号（属于不同集合的符号）混起来。这样我们就有了符号类型（集合）的概念。基本符号的类型井水不犯河水，但我们可以去定义新的类型，把已有的不同类型加起来（variants）或者乘起来（tuples），构建一些新的集合。集合间的运算可以反射到基本符号间的运算，只不过这是定义新的基本符号的形式。

有的函数并不关心类型，这样的函数需要多态。'a就是表达多态的工具。

我们不仅可以把已有的类做些运算，还可以把这些运算组合起来构造新的类型，这就是type constructor。list就是使用了type加法和乘法的type constructor。需要注意的是，构造新类时可以使用自己构造，这就是递归（归纳）定义。

怎么取出这些又加又乘后新造类型中的每个元素的各个组成部分呢？我们可以用pattern matching。对于“加起来”和“乘起来”，pattern matching都是可以获得它们中每个元素的工具。

这些新类型，就框起了新数据结构的框架。我们可以制造出产生这些类型对象的函数，也可以制造出把这些类型对象与基本类型对象对应的函数。这样，数据就在基本类型的加法和乘法下被管的服服帖帖的了，这就是函数式编程的数据结构。函数式编程中数据结构可以更抽象更直观地体现，这就是它的一个优势。
## 函数的函数
把函数作为映射的对象，那就建起了函数的函数，也即把一个关系映射到另一种基本符号或关系的映射。从这个意义上讲，函数也是一种基本符号。这种高阶逻辑嵌套的思想是抽象性原理的精华体现。

对于把大量数据组合起来的数据结构类型，我们很容易定义对每一个单个对象作用的函数，却对大对象束手无策。这时就可以用函数的函数为每个对象量身定制一套把其中每一个元素都映射到其他对象的函数。map和fold就是两个典型例子。map把大对象映射到大对象，fold把大对象映射到一个反映大对象性质的小元素（当然未必，也可能是另一个大对象）。任何数据结构都可以有map和fold。

pipelining是另一个函数的函数。通过把函数调用的顺序扭过来，pipelining可以优美地处理函数的复合。
## 模块化
如何把大量的代码组织起来？把它们分割成只有少数联系的模块是很好的解决办法。在函数式编程中，模块就是一堆函数和一堆自定义类型。模块内部的实施细节藏起来，只留下公共的接口（mli）供其他人使用。OCaml用sig表示接口，只告诉使用者公开的函数名以及这些函数的类型。用struct表示真实的代码，两者必须对应。

面向对象编程的重要思想就是构建一类有自己变量和方法的对象。struct可以实现它，不过你得造一个自己的数据类型，用加起来和乘起来造出一个数据类型，然后限定这个struct的方法（函数）只可以用在你定义的类型上，这就等效于实现了类。把实施细节藏起来，也把你那自定义的数据类型藏了起来，外面看不出这个数据类型和原本的实现中的基本类型有什么关系，这就是抽象性原理。略麻烦一点的是，为每一个struct，现在你必须定义一个t，作为对象。

在面向对象编程中，类与类之间有继承和派生的关系。在OCaml当中，实现继承的简单方法是我可以宣布把另一个模块的适用范围延伸到这里，这样就可以重用代码。但在函数式编程中，另一个解决办法是构造一个从模块（一堆函数）到模块（一堆函数）的映射。由于模块还包含自定义类型，是不同的一层函数抽象，这个映射显然不能与函数的函数等价，我们就把它叫做functor。如果我们在functor中宣布把参数模块的适用范围延伸到这里，我们就实现了代码重用。但functor不仅可以实现代码重用，它还有类似模板的功能。任何满足某个sig的模块（有的sig很简单，只要Comparable就可以了）都可以为我所用，都可以帮助我造出一个新的模块。这样就不仅实现了对基本符号的抽象（变量），对类型的抽象（多态），更实现了对模块的抽象（generics，模板）。
## 高级数据结构
函数式编程中对类型和数据结构的清晰定义让我们能够去探讨更多样的数据结构。
### 无穷数据结构 流 延迟赋值
流是没有递归起点的递归数据结构。但OCaml 编译器的赋值是立即型(eager)：一遇到基本符号，它就想为它赋值（不同语言不同，比如Haskell就不是，除非你想知道它的值，它就是不去赋值）。于是无穷数据结构毫无疑问地将会走向堆栈溢出。怎么办呢？考虑到函数也是一种基本符号，可以让函数作为阻断赋值的工具，即创建一个以unit为参数的dummy函数，让它取代原来的递归，OCaml遇到函数就置之不理了，这样就能成功创建流了。这种结构称为thunk。当然OCaml像Haskell一样也支持延迟赋值，这就是Lazy。

函数式编程的延迟赋值是很重要的特性。不那么急着赋值可以保持某值的相对抽象，某些时候可以节约算力。有时延迟赋值还可以与动态规划结合起来。因为函数式编程具有不可变性的特点，多次赋值相同值时我们可以把前次赋值的结果存起来（尽管存储不是完美的函数式编程特点），后面使用时就免去了重复计算。这就是memoization，即动态规划。
### 函数式编程的可变性特性
函数式编程一个重要特点是不可变性，可哪个语言都要可变，至少它们要IO，因此它们就会产生副作用。函数式编程的特点在于把副作用降到最小，即明确说出什么时候函数会有副作用。以unit为返回值的函数一般认为有副作用，这就是“；”运算符的道理。使用带有命令式编程特点的引用要单独声明，且语法相对复杂，减小了可变性的损失。

OCaml引用的赋值规则规定，在函数定义时，“函数名=”后（多元函数没这回事），”fun关键字”前的let内容多次调用函数只会被赋值一次。这样可以保证制作可变计数器(mutable counter)时外界不会侵扰引用类型的计数器。

### 并发和Promise
操作系统在工作时，假定它需要去完成的任务都是相互独立的，这样它就可以这一秒干干这个，后一秒再干干那个，以防止某个应用逗留太久，这就是并发编程。操作系统默认执行并发，然而，有时我们需要强令某段代码必须于另一段代码后执行，即*杜绝*并发现象。例如IO，不输入就没东西输出。同时有时我们还需要强令某段代码必须在另一段代码执行后（或者是某一现象发生后）立即执行，也就是在那段代码后缀一段必须顺序执行的代码，这就是Listener Pattern。这些现象需要非并发输入输出(asynchronous I/O)。

在OCaml和其他函数式编程语言中，Promise是实现非并发输入输出的工具，实现它的工具包是Lwt。Promise的机制是，让后一个函数变成前一个函数的callback，而前一个函数的输出值是Promise，它会在不确定的未来被解决。Promise就是一张空头支票，意味着这个空会被填上，因此这张空头支票可以被送给很多函数，这样那些函数都只能在空头支票兑现之后执行，这样就杜绝了并发现象。bind函数是一种特殊的通过旧空头支票a制造新空头支票b的函数，它先造出一张空头支票b，b的性质是旧空头支票a兑现时必须立即运行callback函数，生出一个新的空头支票c，而空头支票c与空头支票b一模一样——c解决的同时b也必须被解决。这样b在a解决之后就立即被解决，保证IO不会出现混乱。使用bind函数可在混乱的并行中实现顺序执行。

Promise的最大特点是在把生成结果和处理结果的代码完整分离的情况下还能够实现两者顺序执行。所以Promise适合实现并行(parallelism)，即两端代码可以在不同的终端执行，而最终它们仍会保持指定的顺序。

### Monad（单子）
Promise是一种单子。单子的特点是把一个值用某种特定形式包裹起来(return)，并且要构造一个接收普通函数，把它用在单子上构造出另一个单子的函数(bind)。可以发现Promise的bind就是这里的bind。

在数学上，*单子*是一个自函子(endofunctor)上的幺半群(monoid)。自函子就是一个functor，只不过它把自己这一类的对象映射到另一个自己这一类的对象。而幺半群是一个带有二元运算+的集合，这个运算满足结合律(bind)，且有单位元(return)。单子的bind函数就是一种自定义的，高阶的，满足结合律的运算，且它可以把自己类的对象转化成另一个自己类的对象。这些是类型理论(category theory)主要讨论的内容。就本课程而言，Monad就是一个包裹一个值的需要提供return和bind两个函数的盒子。

用Monad这样一种抽象的编程范式去构建代码有以下优势：1.为对象添加性质（性质写在Monad的两个函数的代码里），同时还能保证迭代结合。2.把特定的函数（例如IO）用Monad组织，把副作用降到最小。3.分离出高阶逻辑，方便地构建顺序运行。

# 编程语言是怎么工作的？
我们经常听到两个概念：编译器和解释器(compiler, interpreter)。编译器和解释器都是翻译语言的工具，它们让我们能够抽象思考。所不同的是，解释器一句一句地翻译程序，读到一个语句就把它执行(Python)，而编译器则一次性大量解析一个程序，把它翻译成一个大机器码文件(C, Java)，留待以后执行。

一个编译器可以分成前端和后端，前端负责把高级语言处理成中间语言，后端则负责把中间语言处理成机器码。前端主要分成三个阶段：词法分析阶段、句法分析阶段、语义分析阶段。词法分析把各种输入的字符串解析成符号。句法分析通过扫过这些符号构造抽象语法树，并在途中检查是否有语法错误。语义分析查看所有变量的类型是否正确，推断没有指定类型的变量，同时检查pattern matching是否完全等等，并造出一张符号表（哪个名字对着哪个变量？），并通过赋值生成中间语言。后端收到中间语言后进行优化（例如无用的变量没必要命名多次，尾递归等），造出一批机器码(x86等等)，最后生成可执行文件。

## 解释器
在这里，我们重点讨论解释器的工作原理。
### 词法分析
词法分析器(lexer)是负责把一个字符串拆解成有意义符号的程序，它与词法分析器生成器(lexer generator)不同。词法分析器生成器是一个程序，它只懂正则语言，接收正则表达式，然后生成一个有限状态机（这个有限状态机是用高级语言实现的）。词法分析器之后将会被用来收取这个语言的语句，接受所有的合法符号，不接受所有的非法符号。词法分析器因此适合分隔符号。
### 句法分析
句法分析阶段处理的内容不再是正则语言的表达式，而是一个上下文无关语言的表达式，通常称为BNF语言。语法分析器（句法分析器, parser）就是一个下推自动机，它接收到一个合法符号后就向下递推，直到所有的符号结束为止。语法分析器的输出就是抽象语法树（AST）。语法分析器是用来读取已经被分隔后符号之间的关系的。语法分析器也有它的生成器(parser generator)。
### 语义分析
在语义分析阶段，我们需要用更高级的语言：上下文有关语言。此阶段我们需要检查所有变量的类型，尤其是某个变量在当前已经定义了一些符号表的语境下的类型。此阶段最重要的内容就是构造一张类型表：哪个变量，哪个表达式代表哪些类型。如果类型表无法构造（自相矛盾），那么类型检查就应该报错。在这一阶段由于要检查类型，所以同时也会检查pattern matching是否穷尽，并执行类型推断。

#### 类型推断
Java，C和Ocaml都是静态类型语言，而Python, Ruby是动态类型语言。OCaml与其他语言都不同的是编者不必明确指明类型。OCaml通过HM算法实现类型推断。HM算法按如下步骤进行：（1）找到表达式中所有已知类型的符号（比如“+”，“3”和“a:int”），代入它们的类型。对于其他所有未指明的符号，暂时使用（'a, 'b, ...）来表示它们的类型，每个符号的类型必须不同。（2）使用let表达式的形式确定对所有类型的约束。确定约束的过程就是去解方程。下面是要解的方程：U(n) = int; U(x) = D(x); U(e1) = U(e2) -> U(e1 e2); U(fun x -> e) = D(x) -> U(e); U(let x = e1 in e2) = U(e2)当D(x) = U(e1)。（3）一步步化简这些约束，以消元法解方程的形式解出所有的约束。若方程无解则产生类型错误，若有无穷多解则把自由变量标成'a, 'b, ...。这样就实现了类型推断。

### 赋值
编译器的赋值是将抽象语法树的节点转化为机器码，而解释器的赋值则是通过化简表达式、给变量赋值的循环真正地把语言指明所要完成的计算执行，从而完成程序的执行。解释器在执行程序之前还可以做一些很简单的优化，例如把语法糖都去掉。赋值阶段是解释器实现中最复杂的阶段。

实现赋值有两种基本方法：小步子和大步子。小步子的特点是每次递归都只执行一次赋值（注意不是代入变量！），即一小步。小步子只在一个函数(step)里实现递归，因而便于深入分析运算的性质（例如优先级和左右结合），但写起来很麻烦。大步子的特点是大量地使用递归，每个赋值函数都可以交叉地使用递归，没有step函数，但有一些eval函数，一层递归可以执行大量的赋值。大步子是大多数解释器采纳的方式。

赋值过程中主要有两件事要做：代入和计算。由于计算的表达式和意义非常清楚，最应该关注的是变量的代入问题。我们为了方便编程，用代号表示一批已有的表达式，或者用代号表示函数期待的输入。最终的程序里没有这些代号，有的只是有效的表达式，因此我们要把基本符号代入这些变量符号中。实现代入变量有两种基本模型：代入模型(substitution model)和环境模型(environment model)，它们都是用来把变量换成其应该代表的表达式的。*切忌不要把代入模型等价于小步子，环境模型等价于大步子。大步子赋值也可以采用代入模型处理变量代入。小步子赋值也可以采用环境模型处理变量代入。*

代入模型的特点是，每次获得了一个变量的表达式（值）后，就把这个值一个一个代入之后所有在有效范围内的该自由变量名。在代入模型中，某个变量必须得完成全部可能的代入才能继续进行赋值，因此使用代入模型代入变量要多次扫过整个程序。在执行代入时，要特别注意代入量的作用范围(scope)和遮挡效应，也即代入的“步子”要适可而止，后定义的同名变量遮挡之前的定义。代入时还要特别注意的是对匿名函数的*避捕代入*(capture avoiding substitution)问题。因为lambda calculus中每个函数都有大量的自由变量，且所有的变量都没有类型，所以每一个匿名函数的函数参数名都不能与需赋的值中的变量名相同，即如果我们要在e中把v赋给x，那么v中的自由变量就绝不能是e的函数参数，否则命名空间就会混淆，此时我们说v中的自由变量被e的函数参数捕获。可以通过起新名字的方法解决lambda calculus中的命名空间问题。注意只有在使用传名调用方法(call by name)时，即函数参数还未赋值时就代入函数，具体计算时再分别赋值的方法，我们才需特殊处理类似lambda calculus的避捕代入问题。在使用传值调用(call by value)时，我们先给函数参数赋值，再代入函数，没有未定义变量的程序是不会出现避捕代入问题的。

环境模型的特点是，每次获得一个变量的值后，先不急代入，维持一张层层相叠的动态符号表作为环境，等到需要某变量的值的时候在符号表中查看它所代表的表达式，再把它代入。在环境模型中，代入与其他计算几乎同时进行，因此使用环境模型代入变量只需对整个程序扫描一次即能完成赋值。环境模型的符号表与前面在语义分析类型检查阶段定义的符号表不一样：前面的符号表把表达式与类型挂钩，而这个符号表把变量名或表达式和与之对应的“环境”挂钩。已知一个变量的名字，不仅要得到其表达式，也要知道与之对应的环境，才能完成对此变量的赋值。这样我们就无需在每一步都代入某变量的值，而把这些信息懒惰地存储在环境中，这种延迟赋值的思想类似thunk的思想。

在环境模型中，特别需要注意的是在函数调用获得变量的表达式值后，这个表达式值应该被添加到哪个环境中。静态作用域（词法作用域,lexical scope）认为这个值应该被添加到函数定义时的环境中，而动态作用域(dynamical scope)则认为这个值应被添加到函数调用时的环境中。静态作用域是目前除了Lisp等少数语言外大多数语言的选择。需要指出的是，动态作用域能很自然地由环境模型实现，而源自代入模型的静态作用域为了被环境模型实现，必须改变环境的数据结构，为其中所有的函数加上*其定义时的环境*，这种包括函数定义环境的存储函数的结构称为闭包(closure)。
## 附录：形式语言和自动机
正则表达式产生正则语言(regular language)，它的语法的特点是线性：一个新符号只能等于一个基本符号与另一个导出符号的组合。任何一个非决定性有限自动机(NFA)都能为正则语言描述。

上下文无关语言(context free language)的特点是非线性：一个新符号可以等于一个基本符号与另一个导出符号前后组合。任何一个下推自动机都能为上下文无关语言所描述。

还有上下文有关语言(context sensitive language)和无限制语言。

# 机器证明与模式识别